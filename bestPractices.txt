ðŸ“Œ C++ Notes â€“ Declarations, Definitions, Keywords, and Best Practices

ðŸ”¹ 1. Declaration vs Definition

Declaration â†’ Tells the compiler what exists (type/signature). No memory allocated.

Definition â†’ Actually allocates memory or provides implementation.

ðŸ‘‰ A variable/function must be declared before use and defined exactly once (ODR rule).

ðŸ”¹ 2. Storage & Linkage Keywords
âœ… auto

Local type deduction (C++11+).

auto x = 5;   // deduces int


Old C++ (pre-11): meant automatic storage duration (default for locals).

âœ… static

Inside function â†’ persists across calls (retains value, stored in Data segment).

Inside class â†’ shared across all objects. Needs definition outside class.

class A { static int count; };
int A::count = 0; // definition


Global/namespace scope â†’ internal linkage (visible only within that file).

Static function â†’ file-local function (cannot be used in other .cpp files).

âœ… extern

Declares a variable/function defined elsewhere.

Used for global variables across multiple .cpp files.

// header.h
extern int g;

// file1.cpp
int g = 10;

// file2.cpp
#include "header.h"
void f() { cout << g; }

âœ… const

Implies read-only after initialization.

Global const â†’ internal linkage by default (not visible across files).

If you want a global constant to be shared across .cpp files â†’ use extern const.

// header.h
extern const int SIZE;

// file1.cpp
const int SIZE = 100;


Inside class â†’ compile-time constant, define in-class if constexpr or static const int.

âœ… inline

Suggests inlining function body (may or may not be done by compiler).

Also changes linkage rules â†’ allows multiple definitions across .cpp files if identical.
ðŸ‘‰ Thatâ€™s why functions are often defined in header files if marked inline.

inline int add(int a, int b) { return a + b; }

âœ… constexpr

Compile-time constant (C++11+).

Must be initialized with constant expressions.

constexpr int square(int x) { return x * x; }

âœ… mutable

Allows modification of a member variable in a const object.

class A {
Â    mutable int counter;
public:
Â    void f() const { counter++; }
};

âœ… friend

Grants another function/class access to private/protected members.

Defined inside class body, but not a member.

ðŸ”¹ 3. Functions Across Files
Case 1: Normal free function

Declare in header, define in .cpp.

// header.h
void foo();

// file.cpp
void foo() { ... }

Case 2: Inline function

Can be both declared & defined in header.

// header.h
inline void foo() { ... }

Case 3: Static function

Defined in .cpp, visible only in that file.

static void helper() { ... }

ðŸ”¹ 4. Variables Across Files

Global variable (shared) â†’ declare with extern in header, define in exactly one .cpp.

Global const â†’ needs extern if shared.

Static global â†’ file-local only.

Static local â†’ persists across calls.

ðŸ”¹ 5. Best Practices for Projects

âœ… Put declarations (functions, extern variables, class definitions) in .h files.
âœ… Put definitions (function bodies, variable definitions) in .cpp files.
âœ… Use inline only for short, frequently used functions.
âœ… Avoid global variables â€“ if needed, prefer const or constexpr.
âœ… Use static for file-local helpers, not global namespace clutter.
âœ… For constants inside classes, prefer static constexpr.
âœ… Never define non-inline functions in headers â†’ linker errors (multiple definitions).
âœ… Use extern carefully to share globals across .cpp files.

ðŸ”¹ 6. Interview/Quick Recall

static â†’ persistence (local), sharing (class), file scope (global).

extern â†’ declaration without definition, tells compiler variable/function is elsewhere.

inline â†’ multiple definitions allowed across TUs if identical.

const vs constexpr â†’ const runtime constant, constexpr compile-time constant.

Definition vs Declaration â†’ declaration = "what", definition = "what + storage".

Headers vs Source â†’ headers for interface, source for implementation.


Interview Revision

ðŸ”¹ Declaration vs Definition

Declaration: Tells the compiler about the name, type, and scope. No memory allocated.

extern int x;   // declaration
int foo(int a); // function declaration


Definition: Allocates memory (for variables) or provides the body (for functions).

int x = 10;       // definition
int foo(int a) { return a+1; } // function definition


ðŸ’¡ Rule: Every identifier must be declared before use, and defined once (ODR â€“ One Definition Rule).

ðŸ”¹ Storage-Class & Qualifiers with Variables
1. auto (modern C++ keyword for type inference)

Old meaning (C++98): Automatic storage (default for local vars, redundant).

Modern meaning (C++11+): Type deduction.

auto x = 5;   // int
auto y = 3.5; // double

2. static

Local variables: Lifetime = program (persist across calls).

void foo() {
Â    static int count = 0; // created once, persists
Â    count++;
}


Global/namespace scope: Internal linkage (only visible in that translation unit).

static int g = 42; // cannot be accessed from other .cpp files


Inside class: Belongs to class, not object. Needs definition outside class.

class Test { static int count; };
int Test::count = 0; // definition

3. const

Local/global variables: Immutable.

const int x = 10;


Global const: By default has internal linkage (unlike normal globals).

If you want to share across files â†’ use extern.

// header.h
extern const int MAX;
// file.cpp
const int MAX = 100;


In classes: Can be initialized in constructor initializer list or with static constexpr.

4. extern

Declares a variable/function defined elsewhere (linker will resolve).

// header.h
extern int g;
// file.cpp
int g = 42;

5. mutable

Can change member variable even in const object.

class A { mutable int cache; };

ðŸ”¹ Functions and Keywords
1. Normal functions

Declared in .h, defined in .cpp.

Good practice: declaration in header, definition in exactly one .cpp file.

2. static functions

At file scope: Internal linkage â†’ visible only in that .cpp.

static void helper(); // cannot be used outside

3. inline functions

Suggests compiler to inline.

Must be defined in header (to be visible in multiple translation units).

inline int add(int a, int b) { return a+b; }

4. constexpr functions (C++11+)

Evaluated at compile-time if arguments are constexpr.

constexpr int square(int x) { return x*x; }

5. friend functions

Declared inside class, defined outside. Can access private members.

ðŸ”¹ File Organization Rules (Best Practices)

Header file (.h / .hpp):

Function declarations.

Class/struct definitions.

inline and constexpr definitions.

extern variable declarations.

const or constexpr globals (if truly constant).

Source file (.cpp):

Function definitions (non-inline).

Global/static variables definitions.

Out-of-class static member definitions.

ðŸ”¹ Interview Quick Checklist

auto â†’ type deduction (C++11+).

static

local â†’ lifetime across calls

global/file â†’ internal linkage

class â†’ shared across all objects, must define outside

const

local/global immutable

global const = internal linkage

share const across files â†’ use extern const

extern â†’ declaration for cross-file usage.

inline â†’ define in header to avoid ODR violation.

static functions â†’ file-local only.

Function rules â†’ declare in .h, define in .cpp, except inline/constexpr.

One Definition Rule (ODR) â†’ exactly one definition, multiple declarations allowed.
